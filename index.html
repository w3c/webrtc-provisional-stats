<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Provisional Identifiers for WebRTC's Statistics API</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  <script class='remove'>
  "use strict";
  // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
  var respecConfig = {
    "doRDFa": false,
    "format": "markdown",
    // "githubAPI": "https://api.github.com/repos/WICG/webrtc-provisional-stats",
    // "issueBase": "https://www.github.com/WICG/webrtc-provisional-stats/issues/",
    "noLegacyStyle": true,
    "editors": [{
        name: "Henrik Bostr√∂m",
        email: "hbos@google.com",
        company: "Google Inc.",
      },
      {
        name: "Harald Alvestrand",
        email: "hta@google.com",
        company: "Google Inc.",
      },
      // Add additional editors here.
      // https://github.com/w3c/respec/wiki/editors
    ],
    "shortName": "webrtc-provisional-stats",
    "specStatus": "unofficial",
    "subjectPrefix": "[webrtc-provisional-stats]",
    "group": "webrtc",
    "github": "https://github.com/w3c/webrtc-provisional-stats/"
  };
  </script>
</head>

<body>
  <section id="abstract">
    <p>
      TODO(hbos): Fill in.
    </p>
  </section>
  <section id="sotd">
    <p>
      This is an unofficial proposal.
    </p>
  </section>
  <section id="introduction">
    <h2>Introduction</h2>
    <p>
      See <a href="https://github.com/w3c/respec/wiki/User's-Guide">ReSpec's
      user guide</a> for how to get started!
    </p>
  </section>
  <section>
    <h3>
      <dfn>RTCCodecType</dfn> enum
    </h3>
    <div>
      <pre class="idl">enum RTCCodecType {
"encode",
"decode",
};</pre>
      <table data-link-for="RTCCodecType" data-dfn-for="RTCCodecType" class="simple">
  <caption>{{RTCCodecType}} Enumeration description</caption>
        <thead>
          <tr>
<th>Enum value</th><th>Description</th>
          </tr>
  </thead>
  <tbody>
          <tr>
            <td>
              <dfn>encode</dfn>
            </td>
            <td>
              <p>
                The attached {{RTCCodecStats}} represents a media format that
                is being encoded, or that the implementation is prepared to encode.
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>decode</dfn>
            </td>
            <td>
              <p>
                The attached {{RTCCodecStats}} represents a media format that
                the implementation is prepared to decode.
              </p>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </section>
  <section id="RTCCodecStats-dict*">
    <h3>
      <dfn>RTCCodecStats</dfn> dictionary non-standardized members
    </h3>
    <pre class="idl">partial dictionary RTCCodecStats {
      RTCCodecType codecType;
};</pre>
    <dl data-link-for="RTCCodecStats" data-dfn-for="RTCCodecStats" class=
    "dictionary-members">
      <dt>
        <dfn>codecType</dfn> of type <span class=
        "idlMemberType">{{RTCCodecType}}</span>
      </dt>
      <dd>
        <p>
          {{RTCCodecType/"encode"}} or {{RTCCodecType/"decode"}}, depending on whether this object
          represents a media format that the implementation is prepared to encode or
          decode. If the dictionary member is not present, it means
          that this media format can be both encoded and decoded.
        </p>
      </dd>
    </dl>
  </section>
  <section id="RTCOutboundRtpStreamStats-dict*">
    <h3>
      <dfn>RTCOutboundRtpStreamStats</dfn> dictionary non-standardized members
    </h3>
    <pre class="idl">partial dictionary RTCOutboundRtpStreamStats {
      DOMString  contentType;
};</pre>
    <dl data-link-for="RTCOutboundRtpStreamStats" data-dfn-for="RTCOutboundRtpStreamStats" class=
    "dictionary-members">
      <dt>
        <dfn><code>contentType</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-DOMString">DOMString</a></span>
      </dt>
      <dd>
        <p>
          This metric exposes the <a href="https://webrtc.org/experiments/rtp-hdrext/video-content-type/" title="video-content-type">video-content-type</a>
          of the last key frame sent. This value is updated every time the last
          packet of a key frame is sent, and it is updated as follows: if this
          packet contained the video-content-type RTP header extension value
          0x00, <code>contentType</code> is <code>"unspecified"</code>, if it is
          0x01, <code>contentType</code> is <code>"screenshare"</code>. In all
          other cases, such as if the header extension is missing, its value is
          invalid or no last packet of a key frame has been sent yet,
          <code>contentType</code> is missing.
        </p>
        </p>
      </dd>
    </dl>
  </section>
  <section id="RTCReceivedRtpStreamStats-dict*">
    <h3>
      <dfn>RTCReceivedRtpStreamStats</dfn> dictionary non-standardized members
    </h3>
    <pre class="idl">partial dictionary RTCReceivedRtpStreamStats {
      unsigned long long   packetsRepaired;
      unsigned long long   burstPacketsLost;
      unsigned long long   burstPacketsDiscarded;
      unsigned long        burstLossCount;
      unsigned long        burstDiscardCount;
      double               burstLossRate;
      double               burstDiscardRate;
      double               gapLossRate;
      double               gapDiscardRate;
      unsigned long        partialFramesLost;
      unsigned long        fullFramesLost;
};</pre>
    <dl data-link-for="RTCReceivedRtpStreamStats" data-dfn-for="RTCReceivedRtpStreamStats" class=
    "dictionary-members">
      <dt>
        <dfn>packetsRepaired</dfn> of type <span class=
        "idlMemberType">unsigned long long</span>
      </dt>
      <dd>
        <p>
          The cumulative number of lost RTP packets repaired after applying an
          error-resilience mechanism [[XRBLOCK-STATS]]. It is measured for the primary
          source RTP packets and only counted for RTP packets that have no further chance
          of repair. To clarify, the value is upper-bound to the cumulative number of lost
          packets. Calculated as defined in [[!RFC7509]] section 3.1 and Appendix A.b.
        </p>
      </dd>
      <dt>
        <dfn>burstPacketsLost</dfn> of type <span class=
        "idlMemberType">unsigned long long</span>
      </dt>
      <dd>
        <p>
          The cumulative number of RTP packets lost during loss bursts, Appendix A (c) of
          [[!RFC6958]].
        </p>
      </dd>
      <dt>
        <dfn>burstPacketsDiscarded</dfn> of type <span class=
        "idlMemberType">unsigned long long</span>
      </dt>
      <dd>
        <p>
          The cumulative number of RTP packets discarded during discard bursts, Appendix A
          (b) of [[!RFC7003]].
        </p>
      </dd>
      <dt>
        <dfn>burstLossCount</dfn> of type <span class="idlMemberType">unsigned
        long</span>
      </dt>
      <dd>
        <p>
          The cumulative number of bursts of lost RTP packets, Appendix A (e) of
          [[!RFC6958]].
        </p>
        <p>
          [[!RFC3611]] recommends a Gmin (threshold) value of 16 for classifying a sequence
          of packet losses or discards as a burst.
        </p>
      </dd>
      <dt>
        <dfn>burstDiscardCount</dfn> of type <span class=
        "idlMemberType">unsigned long</span>
      </dt>
      <dd>
        <p>
          The cumulative number of bursts of discarded RTP packets, Appendix A (e) of
          [[!RFC8015]].
        </p>
      </dd>
      <dt>
        <dfn>burstLossRate</dfn> of type <span class=
        "idlMemberType">double</span>
      </dt>
      <dd>
        <p>
          The fraction of RTP packets lost during bursts to the total number of RTP packets
          expected in the bursts. As defined in Appendix A (a) of [[!RFC7004]], however,
          the actual value is reported without multiplying by 32768.
        </p>
      </dd>
      <dt>
        <dfn>burstDiscardRate</dfn> of type <span class=
        "idlMemberType">double</span>
      </dt>
      <dd>
        <p>
          The fraction of RTP packets discarded during bursts to the total number of RTP
          packets expected in bursts. As defined in Appendix A (e) of [[!RFC7004]],
          however, the actual value is reported without multiplying by 32768.
        </p>
      </dd>
      <dt>
        <dfn>gapLossRate</dfn> of type <span class=
        "idlMemberType">double</span>
      </dt>
      <dd>
        <p>
          The fraction of RTP packets lost during the gap periods. Appendix A (b) of
          [[!RFC7004]], however, the actual value is reported without multiplying by 32768.
        </p>
      </dd>
      <dt>
        <dfn>gapDiscardRate</dfn> of type <span class=
        "idlMemberType">double</span>
      </dt>
      <dd>
        <p>
          The fraction of RTP packets discarded during the gap periods. Appendix A (f) of
          [[!RFC7004]], however, the actual value is reported without multiplying by 32768.
        </p>
      </dd>
      <dt>
        <dfn>partialFramesLost</dfn> of type <span class=
        "idlMemberType">unsigned long</span>
      </dt>
      <dd>
        <p>
          Only exists for video. The cumulative number of partial frames lost. The measurement
          begins when the receiver is created and is a cumulative metric as defined in
          Appendix A (j) of [[!RFC7004]]. This metric is incremented when the frame is sent
          to the decoder. If the partial frame is received and recovered via retransmission
          or FEC before decoding, the <code>framesReceived</code> counter is incremented.
        </p>
      </dd>
      <dt>
        <dfn>fullFramesLost</dfn> of type <span class="idlMemberType">unsigned
        long</span>
      </dt>
      <dd>
        <p>
          Only exists for video. The cumulative number of full frames lost. The measurement
          begins when the receiver is created and is a cumulative metric as defined in
          Appendix A (i) of [[!RFC7004]].
        </p>
      </dd>
    </dl>
  </section>
  <section id="RTCInboundRtpStreamStats-dict*">
    <h3>
      <dfn>RTCInboundRtpStreamStats</dfn> dictionary non-standardized members
    </h3>
    <pre class="idl">partial dictionary RTCInboundRtpStreamStats {
      DOMString            contentType;
      double               jitterBufferTargetDelay;
      unsigned long        frameBitDepth;
      boolean              voiceActivityFlag;
      double               averageRtcpInterval;
      unsigned long long   packetsFailedDecryption;
      unsigned long long   packetsDuplicated;
      record&lt;USVString, unsigned long long&gt; perDscpPacketsReceived;
      unsigned long        sliCount;
      unsigned long long   totalSamplesDecoded;
      unsigned long long   samplesDecodedWithSilk;
      unsigned long long   samplesDecodedWithCelt;
};</pre>
    <dl data-link-for="RTCInboundRtpStreamStats" data-dfn-for="RTCInboundRtpStreamStats" class=
    "dictionary-members">
      <dt>
        <dfn><code>contentType</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-DOMString">DOMString</a></span>
      </dt>
      <dd>
        <p>
          This metric exposes the <a href="https://webrtc.org/experiments/rtp-hdrext/video-content-type/" title="video-content-type">video-content-type</a>
          of the last key frame received. This value is updated every time the
          last packet of a key frame is received, and it is updated as follows:
          if this packet contained the video-content-type RTP header extension
          value 0x00, <code>contentType</code> is <code>"unspecified"</code>, if
          it is 0x01, <code>contentType</code> is <code>"screenshare"</code>. In
          all other cases, such as if the header extension is missing, its value
          is invalid or no last packet of a key frame has been received yet,
          <code>contentType</code> is missing.
        </p>
      </dd>
      <dt>
        <dfn><code>jitterBufferTargetDelay</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-double">double</a></span>
      </dt>
      <dd>
        <p>
          This value is increased by the target jitter buffer delay every time a
          sample is emitted by the jitter buffer. The added target is the target
          delay, in seconds, at the time that the sample was emitted from the
          jitter buffer. To get the average target delay, divide by
          <code>jitterBufferEmittedCount</code>.
        </p>
      </dd>
      <dt>
        <dfn>frameBitDepth</dfn> of type <span class="idlMemberType">unsigned
        long</span>
      </dt>
      <dd>
        <p>
          Only exists for video. Represents the bit depth per pixel of the last decoded frame.
          Typical values are 24, 30, or 36 bits.
          Before the first frame is decoded this member does not exist.
        </p>
      </dd>
      <dt>
        <dfn>voiceActivityFlag</dfn> of type <span class=
        "idlMemberType">boolean</span>
      </dt>
      <dd>
        <p>
          Only exists for audio. Whether the last RTP packet whose frame was delivered to the
          <code>RTCRtpReceiver</code>'s <code>MediaStreamTrack</code> for playout contained voice activity or not based

          on the presence of the V bit in the extension header, as defined in [[RFC6464]]. This
          is the stats-equivalent of <code>RTCRtpSynchronizationSource</code>.<a class=fixme href="https://w3c.github.io/webrtc-extensions/#dom-rtcrtpsynchronizationsource-voiceactivityflag"><code>voiceActivityFlag</code></a>
          in [[WEBRTC].
        </p>
      </dd>
      <dt>
        <dfn>averageRtcpInterval</dfn> of type <span class=
        "idlMemberType">double</span>
      </dt>
      <dd>
        <p>
          The average RTCP interval between two consecutive compound RTCP packets. This is
          calculated by the sending endpoint when sending compound RTCP reports. Compound
          packets must contain at least a RTCP <code>RR</code> or <code>SR</code> block and an SDES packet with the
          CNAME item.
        </p>
      </dd>
      <dt>
        <dfn>packetsFailedDecryption</dfn> of type <span class=
        "idlMemberType">unsigned long long</span>
      </dt>
      <dd>
        <p>
          The cumulative number of RTP packets that failed to be decrypted according to the
          procedures in [[!RFC3711]]. These packets are not counted by
          <code>packetsDiscarded</code>.
        </p>
      </dd>
      <dt>
        <dfn>packetsDuplicated</dfn> of type <span class=
        "idlMemberType">unsigned long long</span>
      </dt>
      <dd>
        The cumulative number of packets discarded because they are duplicated. Duplicate
        packets are not counted in <code>RTCReceivedRtpStreamStats/packetsDiscarded</code>.<br>
        Duplicated packets have the same RTP sequence number and content as a previously
        received packet. If multiple duplicates of a packet are received, all of them are
        counted.<br>
        An improved estimate of lost packets can be calculated by adding
        {{packetsDuplicated}} to <code>RTCReceivedRtpStreamStats/packetsLost</code>; this will always result in a positive
        number, but not the same number as RFC 3550 would calculate.
      </dd>
      <dt>
        <dfn>perDscpPacketsReceived</dfn> of type <span class=
        "idlMemberType">record&lt;USVString, unsigned long long&gt;</span>
      </dt>
      <dd>
        <p>
          Total number of packets received for this <code>SSRC</code>, per Differentiated Services code
          point (DSCP) [[RFC2474]]. DSCPs are identified as decimal integers in string
          form. Note that due to network remapping and bleaching, these numbers are not
          expected to match the numbers seen on sending. Not all OSes make this information
          available.
        </p>
      </dd>
      <dt>
        <dfn>sliCount</dfn> of type <span class="idlMemberType">unsigned
        long</span>
      </dt>
      <dd>
        <p>
          Only exists for video. Count the total number of Slice Loss Indication (SLI)
          packets sent by this receiver. Calculated as defined in [[!RFC4585]] section
          6.3.2.
        </p>
      </dd>
      <dt>
        <dfn>totalSamplesDecoded</dfn> of type <span class=
        "idlMemberType">unsigned long long</span>
      </dt>
      <dd>
        <p>
          Only exists for audio. The total number of samples that have been decoded on this
          RTP stream. 
        </p>
      </dd>
      <dt>
        <dfn>samplesDecodedWithSilk</dfn> of type <span class=
        "idlMemberType">unsigned long long</span>
      </dt>
      <dd>
        <p>
          Only exists for audio and when the audio codec is Opus. The total number of
          samples decoded by the SILK portion of the Opus codec.
        </p>
      </dd>
      <dt>
        <dfn>samplesDecodedWithCelt</dfn> of type <span class=
        "idlMemberType">unsigned long long</span>
      </dt>
      <dd>
        <p>
          Only exists for audio and when the audio codec is Opus. The total number of
          samples decoded by the CELT portion of the Opus codec.
        </p>
      </dd>
    </dl>
  </section>
  <section id="RTCAudioReceiverStats-dict*">
    <h3>
      <dfn>RTCAudioReceiverStats</dfn> dictionary non-standardized members
    </h3>
    <pre class="idl">partial dictionary RTCAudioReceiverStats {
      unsigned long long jitterBufferFlushes;
};</pre>
    <dl data-link-for="RTCAudioReceiverStats" data-dfn-for="RTCAudioReceiverStats" class=
    "dictionary-members">
      <dt>
        <dfn><code>jitterBufferFlushes</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-unsigned-long-long">unsigned long long</a></span>
      </dt>
      <dd>
        <p>
          Experimental stat which is available <a href="https://docs.google.com/document/d/1stYIZhEmDZ7NJF9gjjsM66eLFJUdc-14a3QutrFbIwI/edit#" title="experiment description">under origin trial in Chromium starting from M72 version</a>.
          Counts the total number of times the jitter buffer
          reaches its maximum capacity and gets flushed.
        </p>
      </dd>
    </dl>
  </section>
  <section id="RTCVideoReceiverStats-dict*">
    <h3>
      <dfn>RTCVideoReceiverStats</dfn> dictionary non-standardized members
    </h3>
    <pre class="idl">partial dictionary RTCVideoReceiverStats {
      unsigned long freezeCount;
      unsigned long pauseCount;
      double totalFreezesDuration;
      double totalPausesDuration;
      double totalFramesDuration;
      double sumOfSquaredFramesDuration;
};</pre>
    <dl data-link-for="RTCVideoReceiverStats" data-dfn-for="RTCVideoReceiverStats" class=
    "dictionary-members">
      <dt>
        <dfn><code>freezeCount</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-unsigned-long">unsigned long</a></span>
      </dt>
      <dd>
        <p>
          Count the total number of video freezes experienced by this receiver.
          It is a freeze if frame duration, which is time interval between two
          consecutively rendered frames, is equal or exceeds
          Max(3 * avg_frame_duration_ms, avg_frame_duration_ms + 150), where
          avg_frame_duration_ms is linear average of durations of last 30 rendered
          frames.
        </p>
      </dd>
      <dt>
        <dfn><code>pauseCount</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-unsigned-long">unsigned long</a></span>
      </dt>
      <dd>
        <p>
          Count the total number of video pauses experienced by this receiver.
          Video is considered to be paused if time passed since last received
          packet exceeds 5 seconds.
        </p>
      </dd>
      <dt>
        <dfn><code>totalFreezesDuration</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-double">double</a></span>
      </dt>
      <dd>
        <p>
          Total duration of rendered frames which are considered as frozen (for
          definition of freeze see <a>freezeCount</a>), in seconds. This value
          is updated when a frame is rendered.
        </p>
      </dd>
      <dt>
        <dfn><code>totalPausesDuration</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-double">double</a></span>
      </dt>
      <dd>
        <p>
          Total duration of pauses (for definition of pause see <a>pauseCount</a>),
          in seconds. This value is updated when a frame is rendered.
        </p>
      </dd>
      <dt>
        <dfn><code>totalFramesDuration</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-double">double</a></span>
      </dt>
      <dd>
        <p>
          Total duration of all rendered video frames, in seconds. This value is
          updated when a frame is rendered.
        </p>
      </dd>
      <dt>
        <dfn><code>sumOfSquaredFramesDuration</code></dfn> of type
        <span class="idlMemberType"><a href="https://heycam.github.io/webidl/#idl-unsigned long">double</a></span>
      </dt>
      <dd>
        <p>
          Sum of squared duration of all rendered frames. It can be used to calculate
          harmonic frame rate:
          <p>
            {{ RTCVideoReceiverStats/totalFramesDuration}}<code> / sumOfSquaredFrameDurations</code>
          </p>
          This value is updated when a frame is rendered.
        </p>
      </dd>
    </dl>
  </section>
  <section id="RTCIceServerStats-stat*">
    <h3>
      <dfn>RTCIceServerStats</dfn> dictionary non-standardized members
    </h3>
    <pre class="idl">partial dictionary RTCIceServerStats {
       RTCNetworkType networkType;
};</pre>
    <dl data-link-for="RTCIceServerStats" data-dfn-for="RTCIceServerStats" class="dictionary-members">
      <dt>
        <dfn><code>networkType</code></dfn> of type <span class=
        "idlMemberType"><a>RTCNetworkType</a></span>
      </dt>
      <dd>
        <div class="warning">
          This member is included in this document for historical reasons.
          Additional work is needed to reach consensus on the privacy model.
        </div>
        <p>
          Represents the type of network interface used.
        </p>
      </dd>
    </dl>
  </section>
  <section id="RTCIceCandidateStats-stat*">
    <h3>
      <dfn>RTCIceCandidateStats</dfn> dictionary non-standardized members
    </h3>
    <pre class="idl">partial dictionary RTCIceCandidateStats {
       RTCNetworkType networkType;
};</pre>
    <dl data-link-for="RTCIceCandidateStats" data-dfn-for="RTCIceCandidateStats" class="dictionary-members">
      <dt>
        <dfn><code>networkType</code></dfn> of type <span class=
        "idlMemberType"><a>RTCNetworkType</a></span>
      </dt>
      <dd>
        <div class="warning">
          This member is included in this document for historical reasons.
          Additional work is needed to reach consensus on the privacy model.
        </div>
        <p>
          Represents the type of network interface used by the base of a local candidate
          (the address the ICE agent sends from). Only present for local candidates; it's
          not possible to know what type of network interface a remote candidate is using.
        </p>
        <div class="note">
          This stat only tells you about the network interface used by the first "hop";
          it's possible that a connection will be bottlenecked by another type of network.
          For example, when using Wi-Fi tethering, the <code>networkType</code> of the
          relevant candidate would be <code>"wifi"</code>, even when the next hop is over a
          cellular connection.
        </div>
        <p class="fingerprint">
          This reveals information that would otherwise not be available to web pages,
          which increases the fingerprint surface.
        </p>
      </dd>
    </dl>
  </section>
  <section>
    <h3>
      <dfn>RTCNetworkType</dfn> enum
    </h3>
    <div class="warning">
      This enum is included in this document for historical reasons.
      Additional work is needed to reach consensus on the privacy model.
    </div>
    <div>
      <pre class="idl">
enum RTCNetworkType {
    "bluetooth",
    "cellular",
    "ethernet",
    "wifi",
    "wimax",
    "vpn",
    "unknown"
};</pre>
        <table data-link-for="RTCNetworkType" data-dfn-for="RTCNetworkType" class="simple">
          <tbody>
            <tr>
              <th colspan="2">
                Enumeration description
              </th>
            </tr>
            <tr>
              <td>
                <dfn><code>bluetooth</code></dfn>
              </td>
              <td>
                <p>
                  A Bluetooth connection.
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn><code>cellular</code></dfn>
              </td>
              <td>
                <p>
                  A cellular connection (e.g., EDGE, HSPA, LTE, etc.).
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn><code>ethernet</code></dfn>
              </td>
              <td>
                <p>
                  An Ethernet connection.
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn><code>wifi</code></dfn>
              </td>
              <td>
                <p>
                  A Wi-Fi connection.
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn><code>wimax</code></dfn>
              </td>
              <td>
                <p>
                  A WiMAX connection.
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn><code>vpn</code></dfn>
              </td>
              <td>
                <p>
                  The connection runs over a VPN. The underlying network type is not available.
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn><code>unknown</code></dfn>
              </td>
              <td>
                <p>
                  The user agent is unable or unwilling to identify the underlying connection
                  technology.
                </p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
</body>

</html>
